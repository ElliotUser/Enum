                                Перечисления в Java относятся к типам классов
    Создать экземпляр перечисления с помощью оператора new нельзя, но в остальном перечисление обладает
всеми возможностями, которые имеются у других классов. Перечисления допускают предоставление конструкто-
ров, добавление переменных экземпляров и методов и даже реализацию интерфейсов.
    Важно понимать, что каждая константа перечислимого типа является объектом класса своего перечисления.
Так, если для перечисления определяется конструктор, он вызывается всякий раз, когда создается константа
перечислимого типа. Кроме того, у каждой константы перечислимого типа имеется своя копия любой из пере-
менных экземпляра, объявленных в перечислении.

ПРИМЕР
    В данной версии перечисления Apple добавлено следующее. Во-первых, пере­менная экземпляра price, кото-
рая служит для хранения цены яблока каждого сорта. Во-вторых, конструктор Apple(), которому передается
цена на яблоко. И в-третьих, метод getPrice(), возвращающий значение цены.
    Когда в методе main() объявляется переменная apple, конструктор Apple() вы­зывается один раз для каждой
объявленной константы. Обратите внимание на то, что аргументы конструктору передаются в скобках после каждой
перечисляемой константы, как показано ниже.

Jonathan(lO), GoldenDel(9), RedDel(12), Winesap(15), Cortland(B);

    Эти значения передаются параметру р конструктора Apple(), который затем присваивает их переменной экзем-
пляра price. Опять же конструктор вызывается один раз для каждой константы перечислимого типа.
    У каждой константы перечислимого типа имеется своя копия переменной экземпляра price, поэтому для получе-
ния цены на определенный сорт яблок доста­ точно вызвать метод getPrice(). Например, цена на сорт яблок Winesap
получается в результате следующего вызова в методе main():

Apple.Winesap.getPrice();

    Цены на все сорта яблок получаются при переборе перечисления в цикле for. Копия переменной экземпляра price
существует для каждой константы перечис­лимого типа, поэтому значение, связанное с одной константой, отделено и
отли­чается от значения, связанного с другой константой. Столь эффективный принцип оказывается возможным только
благодаря реализации перечислений в виде классов, как это и сделано в языке Java.

    В предыдущем примере перечисление содержит только один конструктор, но на самом деле в перечислении могут
быть предоставлены две или более перегру­жаемых формы конструкторов, как и в любом другом классе. Например, в
приве­денной ниже версии перечисления Apple дополнительно предоставляется кон­структор по умолчанию, инициализи-
рующий цену значением -1, которое означает, что цена не указана.

enum Apple {
    Jonathan(lO), GoldenDel(9), RedDel, Winesap(l5), Cortland(B);

    private int price; // цена яблока каждого сорта

    // Конструктор
    Apple(int р) {
        price = р;
    }

    // Перегружаемый конструктор
    Apple() {
        price = -1;
    }

    int getPrice ( ) {
        return price ;
    }
}

    Обратите внимание на то, что в этой версии перечисления Apple константе RedDel не передается аргумент. Это
означает, что вызывается конструктор по умолчанию и в переменной price для цены на яблоко сорта RedDel устанав-
ливается значение - 1 .
    Однако на перечисления накладываются два ограничения.

    Во-первых, перечисление не может наследоваться от другого класса.
    Во-вторых, перечисление не может быть суперклассом. Это означает, что перечисление не может быть рас­ширено.

    А в остальном перечисление ведет себя так же, как и любой другой тип класса. Самое главное - не забывать, что
каждая константа перечислимого типа является объектом класса, в котором она определена.